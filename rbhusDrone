#!/usr/bin/python

# CLIENT
import sys
import os
import multiprocessing
import socket
import logging
import time
import signal
import subprocess
if(sys.platform.find("linux") >= 0):
  import pwd

import pickle
import rbhus.db as db
import rbhus.constants as constants
if(sys.platform.find("linux") >= 0):
  import psi
  import psi.process
import tempfile
import inspect

time.sleep(1)

hostname = socket.gethostname()
tempDir = tempfile.gettempdir()
if(sys.platform.find("linux") >=0):
  LOG_FILENAME = '/var/log/rbhusClient.log'
elif(sys.platform.find("win") >=0):
  #LOG_FILENAME = tempDir + os.sep +"rbusClient_"+ str(hostname) +".log"
  LOG_FILENAME = "z:"+ os.sep +"pythonTestWindoze.DONOTDELETE"+ os.sep +"rbhus"+ os.sep +"rbusClient_"+ str(hostname) +".log"
#tempDir + os.sep +"rbusClient_"+ str(hostname) +".log"
logging.BASIC_FORMAT = "%(asctime)s - %(lineno)s -  %(message)s"
logging.basicConfig(filename=LOG_FILENAME,level=logging.DEBUG)

def loggingDebug(msg):
  try:
    logging.debug(msg)
  except:
    pass

def loggingError(msg):
  try:
    logging.error(msg)
  except:
    pass
    
# The most stupid signal handler :)
def sigHandle(sigNum, frame):
  myPid = os.getpid()
  loggingDebug(str(str(inspect.stack()[1][2])) +" : "+ str(inspect.stack()[1][3]) +" : "+"signal handler called with "+ str(sigNum) +" signal")
  loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+"my pid "+ str(myPid))
  # run this only if linux?! .. omfg .. i dont know !!!!
  if(sys.platform.find("linux")):
    killProcessKids(myPid)
  return(1)
  
  
def getProcessLastKids(ppid,lastKids):
  try:
    pidDets = psi.process.Process(ppid)
  except:
    pidDets = None
  try:
    pidKids = pidDets.children()
  except:
    pidKids = None
  if(not pidKids):
    lastKids.append(ppid)
    return(0)
  else:
    for pidKid in pidKids:
      getProcessLastKids(pidKid.pid,lastKids)

      

def getProcessLastKids_win(ppid,lastKids):
  pidKids = getProcessKids_win(ppid)
  if(not pidKids):
    lastKids.append(ppid)
    return(0)
  else:
    for pidKid in pidKids:
      getProcessLastKids_win(pidKid,lastKids)



def getProcessKids_win(ppid):
  result = {}
  pList = "wmic process get handle,parentprocessid"
  response1 = os.popen(pList + ' 2>&1','r').read().strip().split("\r\n")[1:]
  if(response1):
    for x in response1:
      pid,pppid = x.split()
      try:
        result[pppid]
      except:
        result[pppid] = []
      result[pppid].append(pid)
    kidsFound = 0
    for parentId in result.keys():
      if(int(parentId) == int(ppid)):
        kidsFound = 1
        return(result[parentId])
    if(kidsFound == 0):
      return None
  else:
    return None
        


def killProcessKids(ppid):
  try:
    pidDets = psi.process.Process(ppid)
  except:
    loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "No details : "+ str(ppid))
    return(0)
  try:
    pidKids = pidDets.children()
  except:
    loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "No children")
    return(0)
  if(not pidKids):
    loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "killing kid "+ str(ppid))
    os.kill(int(ppid),9)
    return(1)
  else:
    for pidKid in pidKids:
      killProcessKids(pidKid.pid)
   


# Get the host info and update the database.
def init():
  hostname = socket.gethostname()
  totalCpus = multiprocessing.cpu_count()
  totalMem = totalMemInfo()
  ret = setHostInfo(hostname,totalMem['MemTotal'],totalCpus,totalMem['SwapTotal'])
  if(ret == 1):
    return(1)
  return(0)
 
 
def hostUpdater():
  myPid = os.getpid()
  loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "hostUpdater : "+ str(myPid))
  hostname = socket.gethostname()
  while(1):
    time.sleep(2)
    try:
      freeMem = freeMeminfo()
      loads = loadAvg()
      setHostResMem(hostname,freeMem['MemFree'],freeMem['SwapFree'], loads[0], loads[1], loads[2])
    except:
      loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(sys.exc_info()))
      pass
  sys.exit(0)
 
def loadAvg():
  loads = ['0','0','0']
  if(sys.platform.find("linux") >=0):
    try:
      loadFile = open("/proc/loadavg","r")
      load = loadFile.readline()
      loadFile.close()
      loads = []
      loads = load.split()
    except:
      loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(sys.exc_info()))
  elif(sys.platform.find("win") >=0):
    try:
      cmd = "wmic cpu get loadpercentage"
      try:
	load = str(os.popen(cmd + ' 2>&1','r').read().strip().split("\r\n")[1])
      except:
        load = 1
	loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(sys.exc_info()))
      if(load):
        loads = [str(load), '0', '0']
    except:
      loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(sys.exc_info()))
  return(loads)
    
    
    
def upHostAliveStatus(hostName, status):
  try:
    conn = db.connRbhus()
    cursor = conn.cursor()
    cursor.execute("UPDATE hostAlive SET status = "+ str(status) +" WHERE hostName=\'"+ str(hostName) +"\'")
    cursor.close()
    conn.close()
  except:
    return(0)
  return(1)


#This piece of shit should be a forked process which should use the multiprocessing.Queue to add the tasks into it
def getAssignedFrames(qAssigned):
  loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(os.getpid()) + ": getAssignedFrames func")
  while(1):
    hostname = socket.gethostname()
    rows = 0
    #while(1):
    #time.sleep(1)
    try:
      conn = db.connRbhus()
      cursor = conn.cursor(db.dict)
      cursor.execute("SELECT frames.frameId, frames.fThreads, tasks.* FROM frames, tasks \
                      WHERE frames.hostName=\'"+ str(hostname) +"\' \
                      AND tasks.id=frames.id \
                      AND frames.status="+ str(constants.framesAssigned) +" \
                      ORDER BY frames.frameId")
      rows = cursor.fetchall()
      cursor.close()
      conn.close()
    except:
      loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "1 : "+ str(sys.exc_info()[1]))
    if(rows):
      for row in rows:
        qAssigned.put_nowait(row)
        

        while(1):
          try:
            conn = db.connRbhus()
            cursor = conn.cursor()
            cursor.execute("UPDATE frames SET status="+ str(constants.framesPending) +" \
                            WHERE frameId="+ str(row['frameId']) +" \
                            AND id="+ str(row['id']))
            cursor.close()
            conn.close()
            break
          except:
            loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "2 : "+ str(sys.exc_info()[1]))
          time.sleep(1)
    time.sleep(1)

  sys.exit(0)


def runFrames(qRun,frameScrutiny):
  loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(os.getpid()) + ": runFrames func")
  processFrames = []
  while(1):
    time.sleep(0.2)
    hostEff = getEffectiveDetails()
    
    totalPids = multiprocessing.cpu_count()
    if(hostEff):
      eCpus = hostEff['eCpus']
      if(eCpus == 0):
        totalPids = multiprocessing.cpu_count()
      elif(eCpus != 0):
        totalPids = eCpus
      else:
        totalPids = 1
    while(1):
      if(len(processFrames) >= totalPids):
        for i in range(0,len(processFrames)):
          if(processFrames[i].is_alive()):
            pass
          else:
            del(processFrames[i])
            break
        if(len(processFrames) < totalPids):
          break
        if(not processFrames):
          break
      else:
        break
      time.sleep(0.1)
      

    while(1):
      try:
        frameInfo = qRun.get()
        break
      except:
        time.sleep(0.2)
    loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "Got frameInfo : "+ str(frameInfo))
    processFrames.append(multiprocessing.Process(target=execFrames,args=(frameInfo,frameScrutiny,)))
    processFrames[-1].start() 



def execFrames(frameInfo,frameScrutiny):
  loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(os.getpid()) + ": execFrames func : "+ str(frameInfo))
  hostEff = getEffectiveDetails()
  if(hostEff != 0):
    while(1):
      if(setFramesStatus(frameInfo['id'],frameInfo['frameId'],constants.framesRunning) == 1):
        break
      time.sleep(0.1)
      
    os.environ['rbhus_taskId']    = str(frameInfo['id']).lstrip().rstrip()
    os.environ['rbhus_frameId']   = str(frameInfo['frameId']).lstrip().rstrip()
    os.environ['rbhus_user']      = str(frameInfo['user']).lstrip().rstrip()
    os.environ['rbhus_fileName']  = str(frameInfo['fileName']).lstrip().rstrip()
    os.environ['rbhus_btCmd']     = str(frameInfo['beforeTaskCmd']).lstrip().rstrip()
    os.environ['rbhus_fileType']  = str(frameInfo['fileType']).lstrip().rstrip()
    os.environ['rbhus_renderer']  = str(frameInfo['renderer']).lstrip().rstrip()
    os.environ['rbhus_renExtArgs']= str(frameInfo['renExtArgs']).lstrip().rstrip()
    os.environ['rbhus_minRam']    = str(frameInfo['minRam']).lstrip().rstrip()
    os.environ['rbhus_maxRam']    = str(frameInfo['maxRam']).lstrip().rstrip()
    os.environ['rbhus_outDir']    = str(frameInfo['outDir']).lstrip().rstrip()
    os.environ['rbhus_outName']   = str(frameInfo['outName']).lstrip().rstrip()
    os.environ['rbhus_logBase']   = str(frameInfo['logBase']).lstrip().rstrip()
    os.environ['rbhus_pad']       = str(frameInfo['pad']).lstrip().rstrip()
    os.environ['rbhus_atCmd']     = str(frameInfo['afterTaskCmd']).lstrip().rstrip()
    os.environ['rbhus_bfCmd']     = str(frameInfo['beforeFrameCmd']).lstrip().rstrip()
    os.environ['rbhus_afCmd']     = str(frameInfo['afterFrameCmd']).lstrip().rstrip()
    os.environ['rbhus_threads']   = str(frameInfo['fThreads']).lstrip().rstrip()
    
    if(sys.platform.find("linux") >=0):
      ruid = pwd.getpwnam(str(frameInfo['user']).lstrip().rstrip())[2]
      rgid = pwd.getpwnam(str(frameInfo['user']).lstrip().rstrip())[3]
    #envFile = "/tmp/"+ str(myPid) +".rbhus"
    #loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ envFile)
    #envFileDesc = open(envFile,"w")
    #pickle.dump(envPickled,envFileDesc)
    #envFileDesc.close()
    try:
      os.makedirs(str(frameInfo['outDir']),0777)
    except:
      loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "MKDIR : "+ str(sys.exc_info()[1]))
    if(sys.platform.find("linux") >= 0):
      try:
        os.chmod(str(frameInfo['outDir']),0777)
        os.chown(str(frameInfo['outDir']),ruid,rgid)
      except:
        loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "MKDIR : "+ str(sys.exc_info()[1]))
      
      
    try:
      os.makedirs(str(frameInfo['logBase']),0777)
    except:
      loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "MKDIR : "+ str(sys.exc_info()[1]))
    try:
      os.chmod(str(frameInfo['logBase']),0777)
      os.chown(str(frameInfo['logBase']),ruid,rgid)
    except:
      loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "MKDIR : "+ str(sys.exc_info()[1]))
      
      
    #Run the beforeFrame shits
    if(str(frameInfo['beforeFrameCmd']) != 'default'):
      loggingDebug("running beforeFrameCmd :"+ str(frameInfo['beforeFrameCmd']))
      runCommand(str(frameInfo['beforeFrameCmd']))
      
    

    runScript = getDefaultScript(frameInfo['fileType'])
    loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "runScript : "+ str(runScript))
    try:
      if(sys.platform.find("win") >= 0):
        runCmd = os.popen('python.exe '+ runScript +' 2>&1','r').read().strip().split("\r\n")[0]
      elif(sys.platform.find("linux") >= 0):
        runCmd = os.popen('python '+ runScript +' 2>&1','r').read().strip().split("\r\n")[0]
    except:
      loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "runCmd  : "+ str(sys.exc_info()))
      while(1):
        if(setFramesStatus(frameInfo['id'],frameInfo['frameId'],constants.framesFailed) == 1):
          loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "run cmd failed !! 1 :"+ runCmd)
          break
        time.sleep(0.5)

      #Run the afterFrame shits
      if(str(frameInfo['afterFrameCmd']) != 'default'):
        loggingDebug("running afterFrameCmd :"+ str(frameInfo['afterFrameCmd']))
        runCommand(str(frameInfo['afterFrameCmd']))
        
      while(1):
        if(setFreeCpus(frameInfo) ==  1):
          break        
        time.sleep(0.5)
      sys.exit(0)


    loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "RUN CMD :"+ runCmd)

    logFile = str(frameInfo['logBase']).rstrip(os.sep) + os.sep + ".".join(str(frameInfo['fileName']).lstrip(os.sep).rsplit(os.sep)[-1].rsplit(".")[0:-1]) +"_"+ str(frameInfo['frameId']).rjust(4,"0") +".log"
    loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "logFile : "+ str(logFile))
    try:
      logD = open(logFile,"a+",0)
      logD.write("START \n"+ socket.gethostname() +" : "+ time.asctime() +"\n")
    except:
      pass

    while(1):
      if(setFramesStime(frameInfo) == 1):
        break
      time.sleep(0.5)
    
    
    retryThres = 5
    retryCount = 0
    if(sys.platform.find("linux") >=0):
      while(1):
        try:
          loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "/bin/su "+ frameInfo['user'] +" -c \'"+ runCmd +"\' "+ str(logD))
          fProcess = subprocess.Popen("/bin/su "+ frameInfo['user'] +" -c \'"+ runCmd +"\'",shell=True,stdout=logD,stderr=logD)
          break
        except:
          loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(sys.exc_info()))
          retryCount = retryCount + 1
          if(retryCount >= retryThres):
            while(1):
              if(setFramesEtime(frameInfo) == 1):
                break
              time.sleep(0.2)
            loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "retryCount : "+ str(retryCount))
            
            while(1):
              if(setFramesStatus(frameInfo['id'],frameInfo['frameId'],constants.framesFailed) == 1):
                break
              time.sleep(0.2)
            
            #Run the afterFrame shits
            if(str(frameInfo['afterFrameCmd']) != 'default'):
              loggingDebug("running afterFrameCmd :"+ str(frameInfo['afterFrameCmd']))
              runCommand(str(frameInfo['afterFrameCmd']))
              
            while(1):
              if(setFreeCpus(frameInfo) ==  1):
                break
              time.sleep(0.2)
            loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "setFreeCpus  ") 
            
            sys.exit(0)
        time.sleep(1)
            
    elif(sys.platform.find("win") >=0):
      logging.warning("PLATFORM : windoze!")          

      loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(runCmd.split()))
      while(1):
        try:
          loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(runCmd.split())+" : "+str(logD))
          fProcess = subprocess.Popen(runCmd.split(),stdout=logD,stderr=logD)
          break
        except:
          loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(sys.exc_info()))
          retryCount = retryCount + 1
          if(retryCount >= retryThres):
            while(1):
              if(setFramesEtime(frameInfo) == 1):
                break
              time.sleep(0.2)
              
            while(1):
              if(setFramesStatus(frameInfo['id'],frameInfo['frameId'],constants.framesFailed) == 1):
                loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "Break point ZERO")
                break
              time.sleep(0.2)
              
            #Run the afterFrame shits
            if(str(frameInfo['afterFrameCmd']) != 'default'):
              loggingDebug("running afterFrameCmd :"+ str(frameInfo['afterFrameCmd']))
              runCommand(str(frameInfo['afterFrameCmd']))
              
            while(1):
              if(setFreeCpus(frameInfo) ==  1):
                break
              time.sleep(0.2)
              
            sys.exit(0)
	time.sleep(1)

    
    time.sleep(0.1)
    fProcessPid = [fProcess.pid]

    fProcessPid.insert(0,frameInfo) #send the frameInfo in the first 
    loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "Frame pid : "+ str(fProcessPid))
    forScrutiny = fProcessPid
    frameScrutiny.put(forScrutiny)
    

    
    kidsForStatus = []
    pidfileLock = multiprocessing.Lock()
    while(1):
      kidsForStatus = []
      if(sys.platform.find("linux") >= 0):
        if(getProcessLastKids(fProcess.pid,kidsForStatus) == 0):
          break
      elif(sys.platform.find("win") >= 0):
        if(getProcessLastKids_win(fProcess.pid,kidsForStatus) == 0):
          break
      if(len(kidsForStatus) > 0):
        loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "kidsForStatus : "+ str(kidsForStatus))
        while(1):
	  if(writeFramePidFile(pidfileLock,frameInfo['id'],frameInfo['frameId'],kidsForStatus) == 1):
	    break
	  time.sleep(1)
      time.sleep(1)
          
    loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "-------------------------------")   
    loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "kidsForStatus : "+ str(kidsForStatus))    

    time.sleep(0.5)
    try:
      fProcess.wait()
    except:
      loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(sys.exc_info()))
    status = fProcess.returncode
    loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "frame status of pid :"+ str(fProcess.pid) +": "+ str(status))
    
    fStatus = getFrameStatus(frameInfo['id'],frameInfo['frameId'])
    loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "Frame status afterdone 1: "+ str(fStatus[0]['status']))
    
    if((status == 0) and (fStatus[0]['status'] != constants.framesKilled)):
      while(1):
        if(setFramesStatus(frameInfo['id'],frameInfo['frameId'],constants.framesDone) == 1):
          loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "Break point ONE")
          break
        time.sleep(0.2)
    elif(fStatus[0]['status'] != constants.framesKilled):
      while(1):
        if(setFramesStatus(frameInfo['id'],frameInfo['frameId'],constants.framesFailed) == 1):
          loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "Break point TWO")
          break
        time.sleep(0.2)
          
    while(1):
      if(setFramesEtime(frameInfo) == 1):
        loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "Break point THREE")
        break
      time.sleep(0.2)
        

      
    #DOING THIS FOR WINDOWS.. fucking 3dsmax-server doesnt close after rendering!!!! dont know y 3dsmax is still making bussiness!
    time.sleep(0.5)
    if(sys.platform.find("win") >= 0):
      killFrame(frameInfo['id'],frameInfo['frameId'],pidfileLock,-1)
    delFramePidFile(pidfileLock,frameInfo['id'],frameInfo['frameId'])

    
    #Run the afterFrame shits
    if(str(frameInfo['afterFrameCmd']) != 'default'):
      loggingDebug("running afterFrameCmd :"+ str(frameInfo['afterFrameCmd']))
      runCommand(str(frameInfo['afterFrameCmd']))
    
    
    try:
      logD.write(socket.gethostname() +" : "+ time.asctime() +"\nEND\n\n")
      logD.close()
    except:
      pass
    while(1):
      if(setFreeCpus(frameInfo) ==  1):
        loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "Break point FOUR")
        break
      time.sleep(0.2)
    sys.exit(0)


def runCommand(rcmd):
  pro = 0
  try:
    pro = subprocess.Popen(rcmd.rstrip().lstrip().split())
  except:
    loggingError(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "runCommand  : "+ str(rcmd) +":"+ str(sys.exc_info()))
    return(1)
  
  try:
    pro.wait()
  except:
    loggingError(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "runCommand  : "+ str(rcmd) +":"+ str(sys.exc_info()))
    return(1)
    
  return(pro.returncode)              
                
def getFrameStatus(taskId,frameId):
  try:
    conn = db.connRbhus()
    cursor = conn.cursor(db.dict)
    cursor.execute("SELECT frames.status FROM frames \
                    WHERE frames.id = "+ str(taskId) +" \
                    AND frames.frameId = "+ str(frameId))
    rows = cursor.fetchall()
    cursor.close()
    conn.close()
    return(rows)
  except:
    loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(sys.exc_info()))
    return(0)
    
def writeFramePidFile(pidLock,taskId,frameId,pids):
  taskPidF = tempDir + os.sep + "rbhus_"+ str(taskId).rstrip().lstrip() +"_"+ str(frameId).rstrip().lstrip()
  try:
    pidLock.acquire()
    inPids = []
    try:
      taskPidD = open(taskPidF,"r+")
      for inPid in taskPidD.readlines():
	if(inPid and (inPid not in inPids)):
	  inPids.append(inPid)
      taskPidD.close()
    except IOError:
      pass
      
    for pid in pids:
      pid.rstrip().lstrip()
      if(pid and (pid != str(os.getpid())) and (pid not in inPids)):
	inPids.append(pid)
    
    taskPidD = open(taskPidF,"w+")
    for inPid in inPids:
      taskPidD.writelines(str(inPid) +"\n\r")
    taskPidD.close() 
    pidLock.release()
  except:
    loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(sys.exc_info()))
    return(0)
  return(1)

def delFramePidFile(pidLock,taskId,frameId):
  taskPidF = tempDir + os.sep + "rbhus_"+ str(taskId).rstrip().lstrip() +"_"+ str(frameId).rstrip().lstrip()
  try:
    if(pidLock != 0):
      pidLock.acquire()
    os.remove(taskPidF)
    if(pidLock != 0):
      pidLock.release()
    return(1)
  except:
    loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(sys.exc_info()))
    return(0)
    
  
def getFrameInfo(taskid, frameid):
  try:
    conn = db.connRbhus()
    cursor = conn.cursor(db.dict)
    cursor.execute("SELECT * FROM frames \
                    WHERE frames.id="+ str(taskid) +" \
                    AND frames.frameId="+ str(frameid))
    rows = cursor.fetchall()
    cursor.close()
    conn.close()
  except:
    loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "1 : "+ str(sys.exc_info()[1]))
    rows = 0
  return(rows)
    
#error = 1 ; success = 0 
def killFrame(taskId,frameId,pidLock = 0,statusAfterKill = -1):
  taskPidF = tempDir + os.sep + "rbhus_"+ str(taskId).rstrip().lstrip() +"_"+ str(frameId).rstrip().lstrip()
  try:
    if(pidLock != 0):
      pidLock.acquire()
    taskPidD = open(taskPidF,"r")
  except:
    if(pidLock != 0):
      pidLock.release()
    return(1)
  kpids = []
  for kpid in taskPidD.readlines():
    if(kpid):
      kpids.append(kpid.rstrip().lstrip())
  taskPidD.close()
  if(pidLock != 0):
    pidLock.release()
  numPids = len(kpids)
  killFail = 0
  fCount = 0
  for kpid in kpids:
    try:
      kpid.rstrip().lstrip()
      if(sys.platform.find("linux") >= 0):
        if(kpid):
	  try:
	    os.kill(int(kpid),signal.SIGTERM)
	  except:
            fCount = fCount + 1
	    loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "killing problem .. please help me murder this")
      elif(sys.platform.find("win") >= 0):
        if(kpid):
	  try:
	    os.system("taskkill /t /f /pid "+ str(kpid))
	  except:
            fCount = fCount + 1
	    loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "killing problem .. please help me murder this")
    except:
      e = sys.exc_info()[1]
      loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(e))
      killFail += 1
  if((killFail < numPids) and (statusAfterKill != -1)):
    while(1):
      if(setFramesStatus(taskId,frameId,statusAfterKill) == 1):
        break
      time.sleep(0.5)
  return(0)

#For future ref for loading custom envs from files in diff paths
#DOES NOT WORK ON WINDOZE!
#def setSysEnviron(envPath):
  #import glob
  #evnFilesSh = glob.glob(envPath.rstrip("/") +"/*")
  #for envFile in evnFilesSh:
    #envF = open(envFile,"r")
    #for envLine in envF.readlines():
      #if(not envLine.startswith("#")):
        #if(envLine.startswith("export")):
          #os.environ[envLine.split()[-1].split("=")[0]] = envLine.split()[-1].split("=")[1]
  #return(1)
    
  
def frameScrutinizer(frameScrutiny):
  loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(os.getpid()) + ": frameScrutinizer func")
  snoopFramesProcess = [] 
  while(1):
    while(1):
      time.sleep(0.2)
      try:
        frameDets = frameScrutiny.get()
        break
      except:
        pass
      if(len(snoopFramesProcess) > 0):
        for i in range(0,len(snoopFramesProcess)):
          if(snoopFramesProcess[i].is_alive()):
            continue
          else:
            loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "snoopFrameProcess dead : "+ str(snoopFramesProcess[i].pid))
            del(snoopFramesProcess[i])
            break

    ######################HOW THE FUCK TO FIX THIS SHIT!!!!!!! N MAKE IT CROSS_PLATFORM!
    
    snoopFramesProcess.append(multiprocessing.Process(target=snoopFrames,args=(frameDets,)))
    snoopFramesProcess[-1].start()
    
        
#this should inteligently snoop on any more pids that are spawned by the given pids
#
#welll... yes !!! . INTELIGENTLY!!!! :|
#
def snoopFrames(fDets):
  loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(os.getpid()) + ": snoopFrames func")
  frameInfo = fDets.pop(0)
  ProcessPid = fDets.pop(0)
  forMean = []
  
  loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(os.getpid()) + ": snoopFrames func : "+ str(ProcessPid) +" : "+ str(frameInfo))
  lastKids = []
  while(1):
    lastKids = []
    vmSize = 0
    if(sys.platform.find("win") >= 0):
      lKids = getProcessLastKids_win(ProcessPid,lastKids)
      if(lKids == 0):
        break
    elif(sys.platform.find("linux") >= 0):
      lKids = getProcessLastKids(ProcessPid,lastKids)
      if(lKids == 0):
        break
    if(len(lastKids) != 0):
      for framePid in lastKids:
        vmSize = vmSize + int(getProcessVmSize(framePid))
      forMean.append(vmSize)
      forMean.sort()
      vmSizeAvg = forMean[(len(forMean)-1)/2]
      setFramesVmSize(frameInfo,vmSizeAvg)
      time.sleep(1)
    else:
      continue
  if(len(forMean) > 0):
    forMean.sort()
    vmSizeAvg = forMean[len(forMean)/2]
    while(1):
      if(setFramesVmSize(frameInfo,vmSizeAvg) == 1):
        break
      time.sleep(1)
  sys.exit(0)
      
        
def getProcessVmSize(pid):
  vmSizeRet = 0
  if(sys.platform.find("win") >= 0):
    try:
      cmd = "wmic process "+ str(pid) +" get workingsetsize"
      vmSizeRet = os.popen(cmd + ' 2>&1','r').read().strip().split("\r\n")[1]
    except:
      return(0)
  elif(sys.platform.find("linux") >= 0):
    try:
      pidFile = open("/proc/"+ str(pid) +"/status","r")
      for line in pidFile.readlines():
        if(line.find('VmPeak') == 0):
          pidFile.close()
          vmSizeRet = line.lstrip().rstrip().split()[1]
    except:
      return(0)
  return(vmSizeRet)
  
  
def setFramesVmSize(frameInfo,vmSize):
  try:
    conn = db.connRbhus()
    cursor = conn.cursor()
    cursor.execute("UPDATE frames SET ram="+ str(vmSize) +" \
                    WHERE frameId="+ str(frameInfo['frameId']) +" \
                    AND id="+ str(frameInfo['id']))
    cursor.close()
    conn.close()
  except:
    return(0)
  return(1)


def setFramesStime(frameInfo):
  try:
    conn = db.connRbhus()
    cursor = conn.cursor()
    cursor.execute("UPDATE frames SET sTime=NOW() \
                    WHERE frameId="+ str(frameInfo['frameId']) +" \
                    AND id="+ str(frameInfo['id']))
    cursor.close()
    conn.close()
  except:
    return(0)
  return(1)


def setFramesEtime(frameInfo):
  try:
    conn = db.connRbhus()
    cursor = conn.cursor()
    cursor.execute("UPDATE frames SET eTime=NOW() \
                    WHERE frameId="+ str(frameInfo['frameId']) +" \
                    AND id="+ str(frameInfo['id']))
    cursor.close()
    conn.close()
  except:
    loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(sys.exc_info()))
    return(0)
  return(1)
    
    
def getDefaultScript(fileType):
  try:
    conn = db.connRbhus()
    cursor = conn.cursor()
    cursor.execute("SELECT defScript FROM fileType WHERE fileType.fileType=\'"+ fileType +"\'")
    rows = cursor.fetchall()
    cursor.close()
    conn.close()
  except:
    return(0)
  if(rows):
    return((rows[0])[0].rstrip().lstrip())
  else:
    loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "NO SCRIPT")
    return(0)
  
def setFramesStatus(taskId, frameId, status):
  try:
    conn = db.connRbhus()
    cursor = conn.cursor()
    cursor.execute("UPDATE frames SET status="+ str(status) +" \
                    WHERE frameId="+ str(frameId) +" \
                    AND id="+ str(taskId))
    cursor.close()
    conn.close()
  except:
    return(0)
  return(1)
    
  
def getEffectiveDetails():
  hostname = socket.gethostname()
  try:
    conn = db.connRbhus()
    cursor = conn.cursor(db.dict)
    cursor.execute("SELECT * FROM hostEffectiveResource WHERE hostName=\'"+ hostname +"\'")
    rows = cursor.fetchall()
    cursor.close()
    conn.close()
  except:
    return(0)
  return(rows[0])
    

   
#If not used remove
 
def atUrService():
  loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(os.getpid()) + ": atUrService func")
  yesMan = 1
  while(yesMan):
    time.sleep(1)
    try:
      hostName = socket.gethostname()
      serverSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
      serverSocket.bind(("", 6660))
      serverSocket.listen(5)
      yesMan = 0
    except:
      pass
  while(1):
    clientSocket, address = serverSocket.accept()
    loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "I got a connection from "+ str(address))
    data = clientSocket.recv(1024)
    data = data.rstrip()
    data = data.lstrip()
    msg = ""
    value = ""
    if(data.rfind(":") != -1):
      msg, value = data.split(":")
    else:
      msg = data
    if(msg == "ALIVE"):
      clientSocket.send("ALIVE")
    elif(msg == "MURDER"):
      try:
        taskId, frameId = value.split("%")
      except:
        continue
      frameInfos = getFrameInfo(taskId, frameId)
      killFrame(taskId,frameId,0,constants.framesKilled)
      delFramePidFile(0,taskId,frameId)
      #while(1):
        #if(setFreeCpus(frameInfos) == 1):
          #break
        #time.sleep(0.2)
    elif(msg == "RESTART"):
      if(sys.platform.find("linux") >= 0):
	try:
	  os.system("reboot >& /dev/null &")
	except:
	  loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ msg)
      elif(sys.platform.find("win") >= 0):
	try:
	  os.system("shutdown /r /t 1")
	except:
	  loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ msg)
    elif(msg == "DELETE"):
      if(os.path.isfile(value)):
	try:
	  os.remove(value)
	except:
	  loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ msg)
    else:
      loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ msg)
  try:
    clientSocket.close()
  except:
    pass
    
    

# Return a dict of totalSwap and totalMem
def totalMemInfo():
  memDetails = {}
  if(sys.platform.find("linux") >=0):
    meminfo = open("/proc/meminfo","r")
    for x in meminfo.readlines():
      if(x.find("MemTotal") != -1):
        memDetails[x.rstrip().split(":")[0].strip().split()[0]] = x.rstrip().split(":")[1].strip().split()[0]
      if(x.find("SwapTotal") != -1):
        memDetails[x.rstrip().split(":")[0].strip().split()[0]] = x.rstrip().split(":")[1].strip().split()[0]
    meminfo.close()
  elif(sys.platform.find("win") >=0):
    totalSwapCmd = "wmic os get sizestoredinpagingfiles"
    totalMemCmd = "wmic os get totalvisiblememorysize"
    memDetails["MemTotal"] = os.popen(totalMemCmd + ' 2>&1','r').read().strip().split("\r\n")[1]
    memDetails["SwapTotal"] = os.popen(totalSwapCmd + ' 2>&1','r').read().strip().split("\r\n")[1]
  loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(memDetails))
  return(memDetails)
  
  
# Return a dict of freeSwap and freeMem
def freeMeminfo():
  memDetails = {}
  if(sys.platform.find("linux") >=0):
    meminfo = open("/proc/meminfo","r")
    for x in meminfo.readlines():
      if(x.find("MemFree") != -1):
        memDetails[x.rstrip().split(":")[0].strip().split()[0]] = x.rstrip().split(":")[1].strip().split()[0]
      if(x.find("SwapFree") != -1):
        memDetails[x.rstrip().split(":")[0].strip().split()[0]] = x.rstrip().split(":")[1].strip().split()[0]
    meminfo.close()
  elif(sys.platform.find("win") >=0):
    freeRamCmd = "wmic os get freephysicalmemory"
    freeSwapCmd = "wmic os get freespaceinpagingfiles"
    memDetails["MemFree"] = os.popen(freeRamCmd + ' 2>&1','r').read().strip().split("\r\n")[1]
    memDetails["SwapFree"] = os.popen(freeSwapCmd + ' 2>&1','r').read().strip().split("\r\n")[1]
    
  return(memDetails)
    
  

def setHostInfo(hostName,totalRam=0,totalCpus=0,totalSwap=0):
  while(1):
    time.sleep(0.1)
    try:
      ipAddr = socket.gethostbyname(socket.gethostname()).strip()
      loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "ipaddr : "+ str(ipAddr))
      try:
	conn = db.connRbhus()
	cursor = conn.cursor()
        cursor.execute("SELECT * FROM hostInfo WHERE hostName = \'" + hostName + "\'")
      except:
        loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(sys.exc_info()))
        continue
      if(not cursor.fetchall()):
        loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "Hostname is new :)")
        try:
	  cursor.execute("INSERT INTO hostInfo \
			  (hostName,totalRam,totalCpus,totalSwap,ip) \
			  VALUES (\'" \
			  + str(hostName) + "\', " \
			  + str(totalRam) + "," \
			  + str(totalCpus) + "," \
			  + str(totalSwap) + ",\'" \
			  + str(ipAddr) + "\')")
	except:
          loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(sys.exc_info()))
      else:
        loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(sys.exc_info()))
        try:
          cursor.execute("UPDATE hostInfo SET \
                          totalRam='"+ str(totalRam) +"', \
                          totalCpus='"+ str(totalCpus) +"', \
                          totalSwap='"+ str(totalSwap) +"' \
                          WHERE hostName = \'"+ str(hostName) +"\'")
        except:
          loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(sys.exc_info()))
        
      
      try:
        cursor.execute("SELECT * FROM hostResource WHERE hostName = \'" + str(hostName) + "\'")
      except:
        loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(sys.exc_info()))
      if(not cursor.fetchall()):  
        try:
          loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : Trying to insert hostResource")
	  cursor.execute("INSERT INTO hostResource (hostName, freeCpus) VALUES (\'" 
			  + hostName +"\'," \
			  + str(totalCpus) +")")
	except:
          loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(sys.exc_info()))
          #try:
            #cursor.execute("UPDATE hostResource SET freeCpus="+ str(totalCpus) +" WHERE hostName = \'"+ hostName +"\'")
          #except:
            #loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(sys.exc_info()))
      else:
        try:
          loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : Trying to update hostResource")
          cursor.execute("UPDATE hostResource SET freeCpus=\'"+ str(totalCpus) +"\' WHERE hostName=\'"+ str(hostName) +"\'")
        except:
          loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(sys.exc_info()))
      
      try:
        cursor.execute("SELECT * FROM hostAlive WHERE hostName=\'" + hostName + "\'")
      except:
        loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(sys.exc_info()))
      if(not cursor.fetchall()):  
        try:
          loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : Trying to insert hostAlive")
	  cursor.execute("INSERT INTO hostAlive (hostName) VALUES (\'"+ str(hostName) +"\')")
	except:
          loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(sys.exc_info()))
          #upHostAliveStatus(hostName, 1)
      
      
      try:
        cursor.execute("SELECT * FROM hostEffectiveResource WHERE hostName=\'" + str(hostName) + "\'")
      except:
        loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(sys.exc_info()))
      if(not cursor.fetchall()):
        try:
          cursor.execute("INSERT INTO hostEffectiveResource (hostName) VALUES (\'"+ str(hostName) +"\')")  
	except:
	  loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(sys.exc_info()))
	  continue
      
      #upHostAliveStatus(hostName, 1)
      cursor.close()
      conn.close()
      break
    except:
      loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(sys.exc_info()))
      pass

  
def setHostResMem(hostName,freeRam=0,freeSwap=0, load1=0, load5=0, load10=0, status=0):
  try:
    conn = db.connRbhus()
    cursor = conn.cursor()
    cursor.execute("UPDATE hostResource SET freeRam=" + str(freeRam) \
	      +", freeSwap="+ str(freeSwap) \
	      +", load1="+ str(load1) \
	      +", load5="+ str(load5) \
	      +", load10="+ str(load10) \
	      +" WHERE hostName=\'"+ str(hostName) +"\'")
    cursor.close()
    conn.close()
  except:
    return(0)
  return(1)   
  
def setFreeCpus(frameInfo):
  hostName = socket.gethostname()
  try:
    conn = db.connRbhus()
    cursorSet = conn.cursor()
    cursorSet.execute("UPDATE hostResource SET freeCpus=freeCpus+"+ str(frameInfo['fThreads']) +" WHERE hostName=\'"+ str(hostName) +"\'")
    cursorSet.close()
    conn.close()
    loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : freeing CPUs : "+ str(hostName) +":"+ str(frameInfo['fThreads']))
  except:
    loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(sys.exc_info()))
    return(0)
  return(1)
    

def mainFunc():
  loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ str(os.getpid()) + ": main func")
  signal.signal(signal.SIGTERM,sigHandle)
  myPid = os.getpid()
  loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "Rbhus : "+ str(myPid))
  p = []
  init()
  
  frameFcuk = multiprocessing.Queue()
  frameScrutiny = multiprocessing.Queue()
  
  hostUpdaterProcess = multiprocessing.Process(target=hostUpdater)
  p.append(hostUpdaterProcess)
  hostUpdaterProcess.start()

  getAssignedFramesProcess = multiprocessing.Process(target=getAssignedFrames,args=(frameFcuk,))
  p.append(getAssignedFramesProcess)
  getAssignedFramesProcess.start()

  runFramesProcess = multiprocessing.Process(target=runFrames,args=(frameFcuk,frameScrutiny,))
  p.append(runFramesProcess)
  runFramesProcess.start()

  atUrServiceProcess = multiprocessing.Process(target=atUrService)
  p.append(atUrServiceProcess)
  atUrServiceProcess.start()
  
  frameScrutinizerProcess = multiprocessing.Process(target=frameScrutinizer,args=(frameScrutiny,))
  p.append(frameScrutinizerProcess)
  frameScrutinizerProcess.start()
  
  
  
  frameFcuk.close()
  frameFcuk.join_thread()
  frameScrutiny.close()
  frameScrutiny.join_thread()
  
  
  while(1):
    time.sleep(0.5)
    for i in range(0,len(p)):
      if(p[i].is_alive()):
        time.sleep(0.5)
      else: 
        loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "MAIN Process dead : "+ str(p[i].pid))
        try:
          del(p[i])
        except:
          loggingDebug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "MAIN Process dead . cannot delete index")
        break
    if(not p):
      break
  
  time.sleep(10)    
  

if __name__ == "__main__":
  mainFunc()
