#!/usr/bin/python
###
# Copyright (C) 2012  Shrinidhi Rao shrinidhi@clickbeetle.in
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
###

# SERVER!!!!!!!!
import sys
import multiprocessing
import socket
import posix
import os
import logging
import time
import signal
import setproctitle
import inspect
import tempfile
import rbhus.dbRbhus as dbRbhus
import rbhus.constants as constants
import psi
import psi.process

LOG_FILENAME = '/var/log/rbhusServer.log'
logging.BASIC_FORMAT = "%(asctime)s - %(funcName)s - %(levelname)s - %(message)s"
logging.basicConfig(filename=LOG_FILENAME,level=logging.DEBUG)

db_conn = dbRbhus.dbRbhus()
tempDir = tempfile.gettempdir()
mainPidFile = tempDir + os.sep +"rbusServer.pids"
time.sleep(5)

def sigHandle(sigNum, frame):
  logging.debug("signal handler called with " + str(sigNum) +" signal")
  killProcessKids()
  return(1)

def killProcessKids():
  allPids = getMainPids()
  if(allPids):
    for x in allPids:
      logging.debug("killing kid "+ str(x))
      os.system("kill -9 "+ str(x))
  
  
# Get all the info on the hosts 
def getHostInfo(status):
  try:
    if(status == "ALL"):
      rows9 = db_conn.execute("SELECT * FROM hostInfo", dictionary=True)
    elif(status == "ENABLED"):
      rows9 = db_conn.execute("SELECT * FROM hostInfo WHERE status="+ str(constants.hostInfoEnable), dictionary=True)
    else:
      rows9 = db_conn.execute("SELECT * FROM hostInfo WHERE status="+ str(constants.hostInfoDisable), dictionary=True)
  except:
    logging.error(str(sys.exc_info()))
    return(0)
  return(rows9)
  

  
  #These are the tasks that need to get inserted into "frames" table 
def getWaitingTasks(pendingTasks):
  setproctitle.setproctitle("getPendingTasks")
  #db_conn = dbRbhus.dbRbhus()
  while(1):
    rows = 0
    #logging.error("ROWS WTF2 : "+ str(rows))
    rows = db_conn.execute("SELECT * FROM tasks WHERE status="+ str(constants.taskWaiting), dictionary=True)
    #logging.error("ROWS WTF3 : "+ str(rows))
    if(rows):
      for row in rows:
        if(row):
          pendingTasks.put(row)
          idTask = row['id']
          #logging.debug("Adding task wtf: "+ str(row))
          ##DO NOT REMOVE THE PENDING STATUS
          while(1):
            try:  
              db_conn.execute("UPDATE tasks SET status="+ str(constants.taskPending) +" WHERE (id = "+ str(idTask) +") and ( status = "+ str(constants.taskWaiting) +")")
              #logging.debug("updating tasks table with pending status wtf4")
              break
            except:
              logging.error("Screwed updating tasks table with pending status : "+ str(sys.exc_info()))
              continue
            time.sleep(0.1)
            
          try:
            db_conn.execute("INSERT INTO tasksLog (id) VALUES ("+ str(idTask) +")")
          except:
            e = sys.exc_info()
            logging.error("Screwed inserting into tasklog : "+ str(e))
          #time.sleep(0.1)
    time.sleep(1)

  
def initWaitingTasks(pendingTasks):
  setproctitle.setproctitle("initWaitingTasks")
  #db_conn = dbRbhus.dbRbhus()
  while(1):
    row = {}
    while(1):
      try:
        row = pendingTasks.get(False)
        break
      except:
        #logging.error("Screwed initWaitingTasks WTF1 : "+ str(sys.exc_info()))
        time.sleep(0.2)
    if(row):  
      idTask = row['id']
      fRange = row['fRange']
      frames = []
      
      for a in fRange.split(","):
        frange = a.split(":")
        pad = 1
        Frange = frange[0]
        if(len(frange) == 2):
          pad = frange[1]
        logging.debug("PAD : "+ str(pad))
        logging.debug(str(int(Frange.split("-")[0])))
        logging.debug(str(int(Frange.split("-")[-1]) + 1))
        for b in range(int(Frange.split("-")[0]), int(Frange.split("-")[-1]) + 1, int(pad)):
          frames.append(b)
          
      tFrames = []
      framesTable = 0
      while(1):
        try:
          framesTable = getAllFrames(idTask)
          break
        except:
          pass
        time.sleep(0.5)
        
      if(framesTable):
        for frameTable in framesTable:
          tFrames.append(frameTable['frameId'])
      
      tFramesSet = set(tFrames)
      framesSet = set(frames)
      forDelSet = tFramesSet.difference(framesSet)
      for forDel in forDelSet:
        while(1):
          try:
            db_conn.execute("DELETE FROM frames WHERE frames.id="+ str(idTask) +" AND frameId="+ str(forDel))
            break
          except:
            logging.error("Screwed initWaitingTasks (Delete frames table (connection)) : "+ str(sys.exc_info()))
          time.sleep(0.1)
    
      for frame in frames:
        while(1):
          try:
            db_conn.execute("INSERT INTO frames (id, frameId) VALUES ("+ str(idTask) +", "+ str(frame) +")")
            break
          except:
            logging.error("Screwed initWaitingTasks (Insert frames table (connection)) : "+ str(idTask) +" : "+ str(sys.exc_info()))
            if(str(sys.exc_info()).find("IntegrityError") >= 0):
              break
          time.sleep(0.1)

      logging.debug("Initialized frames table")
      while(1):
        try:
          db_conn.execute("UPDATE tasks SET status="+ str(constants.taskActive) +" WHERE id="+ str(idTask))
          logging.debug("Updated task:"+ str(idTask) +" status to 2(active)")
          break
        except:
          logging.error("Screwed initWaitingTasks : "+ str(sys.exc_info()))
        time.sleep(0.1)
    time.sleep(0.1)
        


def getActiveTasks():
  try:
    rows1 = db_conn.execute("SELECT tasks.*, tasksLog.lastHost FROM tasks, tasksLog \
                    WHERE tasks.status=\'"+ str(constants.taskActive) +"\' \
                    AND tasks.id=tasksLog.id \
                    AND tasks.afterTime<=NOW() \
                    ORDER BY tasks.priority DESC", dictionary=True)
    
    #THE BELOW LOGIC IS NONSENSE . this is a temp fix untill i find the right source of the problem
    if(rows1):
      if(not 'priority' in rows1[0].keys()):
        print("faaaaaaaaack ..getActiveTasks missed!!!! ")
        return(0)
  except:
    logging.error(str(sys.exc_info()))
    return(0)
  return(rows1)
    

def getUnassignedFrames(taskId):
  try:
    rows2 = db_conn.execute("SELECT frames.frameId, tasks.* FROM frames, tasks \
                    WHERE tasks.id="+ str(taskId) +" \
                    AND frames.id= tasks.id \
                    AND frames.status="+ str(constants.framesUnassigned) +" \
                    AND (tasks.rerunThresh>frames.runCount OR tasks.rerunThresh=0) \
                    ORDER BY frames.frameId", dictionary=True)
  except:
    logging.error(str(sys.exc_info()))
    return(0)
  return(rows2)
  
  

    
def getPotentHosts():
  try:
    rows3 = db_conn.execute("SELECT hostInfo.hostName, \
                           hostInfo.totalCpus, \
                           hostResource.freeCpus, \
                           hostInfo.totalRam, \
                           hostResource.freeRam, \
                           hostInfo.totalSwap, \
                           hostResource.freeSwap, \
                           hostResource.load1, \
                           hostResource.load5, \
                           hostResource.load10, \
                           hostEffectiveResource.eCpus, \
                           hostInfo.weight, \
                           hostInfo.groups, \
                           hostInfo.os \
                     FROM hostResource, hostInfo, hostAlive, hostEffectiveResource \
                     WHERE hostInfo.status = hostAlive.status \
                     AND hostAlive.status="+ str(constants.hostAliveAlive) +" \
                     AND hostInfo.hostName = hostResource.hostName \
                     AND hostResource.hostName = hostAlive.hostName \
                     AND hostAlive.hostName = hostEffectiveResource.hostName \
                     ORDER BY hostInfo.weight DESC", dictionary=True)
    

  except:
    logging.error(str(sys.exc_info()))    
    return(0)
  return(rows3)
  

def getFreeHosts():
  freeHosts = []
  potentHosts = getPotentHosts()
  #logging.debug("potentHosts : "+ str(potentHosts))
  if(potentHosts):
    for hostDetails in potentHosts:
      if(hostDetails["eCpus"] == 0):
        hostDetails["eCpus"] = hostDetails["totalCpus"]
        if((hostDetails["freeCpus"] <= hostDetails["totalCpus"]) and (hostDetails["freeCpus"] > 0)):
          freeHosts.append(hostDetails)
      elif(hostDetails['eCpus'] != 0):
        if((hostDetails["totalCpus"] - hostDetails["freeCpus"]) < hostDetails["eCpus"]):
          freeHosts.append(hostDetails)
  return(freeHosts)
      

def checkClientAlive():
  setproctitle.setproctitle("checkClientAlive")
  #db_conn = dbRbhus.dbRbhus()
  maxPids = 100
  pIds = []
  while(1):
    time.sleep(30)
    hostInfos = getHostInfo(status="ALL")
    if(not hostInfos):
      continue
    
    while(1):
      if(len(pIds) >= maxPids):
        for i in range(0,len(pIds)):
          if(pIds[i].is_alive()):
            pass
          else:
            del(pIds[i])
            break
        if(len(pIds) < maxPids):
          break
        if(not pIds):
          break
      else:
        break
      time.sleep(1)
    
    for hostInfo in hostInfos:
      hostName = hostInfo['hostName']
      ipAddr = hostInfo['ip']
      logging.debug("Pinging "+ hostName + " with ip : "+ str(ipAddr))
      
      pingClientProcess_proc = multiprocessing.Process(target=pingClientProcess, args=(hostName,ipAddr,))
      pIds.append(pingClientProcess_proc)
      pingClientProcess_proc.start()
      
      while(1):
        for i in range(0,len(pIds)):
          if(pIds[i].is_alive()):
            pass
          else:
            del(pIds[i])
            break
        if(len(pIds) < maxPids):
          break
        if(not pIds):
          break
        time.sleep(1)
      

def pingClientProcess(client,ipAddr):
  setproctitle.setproctitle("ping_"+ str(client))
  #db_conn = dbRbhus.dbRbhus()
  status = os.system("ping -c 1 -W 15 "+ str(ipAddr) +" >& /dev/null")
  pingstatus = 0
  sockstatus = 0
  if(status == 0):
    logging.debug("Connected to "+ client)
    pingstatus = 1
  else:
    logging.debug("Not able to connect to "+ client)
    while(1):
      if((setHostAliveStatus(client,constants.hostAliveDead) == 1) and (resetAssignedFrame(client, constants.framesHung) == 1)):
        break
      time.sleep(0.3)
    sys.exit(1)

  clientSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  tryCount = 5 
  while(1):
    tryCount = tryCount - 1
    try:
      clientSocket.connect((ipAddr,6660))
      clientSocket.settimeout(3)
      logging.debug("Connected to "+ client)
      sockstatus = 1
      break
    except:
      logging.error("Screwed pingClientProcess sock connect : "+ client +" : "+ str(sys.exc_info()))
      sockstatus = 0
      clientSocket.close()
    time.sleep(5)
    if(tryCount <= 0):
      break
  if(tryCount <= 0):
    while(1):
      if((setHostAliveStatus(client,constants.hostAliveDead) == 1) and (resetAssignedFrame(client, constants.framesHung) == 1)):
        break
      time.sleep(0.3)
      clientSocket.close()
    sys.exit(1)

  clientSocket.send("ALIVE")
  reply = ""
  try:
    reply = clientSocket.recv(1024)
    clientSocket.close()
    sockstatus = 1
  except:
    e = sys.exc_info()[1]
    logging.error("Screwed pingClientProcess sock send : "+ client +" : "+ str(e))
    sockstatus = 0
    clientSocket.close()
    #exit(1)
  if((sockstatus == 1) and (pingstatus == 1)):
    while(1):
      if(setHostAliveStatus(client,constants.hostAliveAlive) == 1):
        break
      time.sleep(0.3)
    pass
  else:
    while(1):
      if((setHostAliveStatus(client,constants.hostAliveDead) == 1) and (resetAssignedFrame(client, constants.framesHung) == 1)):
        break
      time.sleep(0.3)

  sys.exit(0)


def setHostAliveStatus(hostName, status):
  try:
    db_conn.execute("UPDATE hostAlive SET status='"+ str(status) +"' WHERE hostName=\""+ hostName +"\"")
    return(1)
  except:
    return(0)
    
def resetAssignedFrame(hostName, statusReset=0):
  try:
    db_conn.execute("UPDATE frames SET status="+ str(statusReset) +" \
                    WHERE hostName=\""+ hostName +"\" AND ((status = "+ str(constants.framesPending) +") \
                    OR (status = "+ str(constants.framesAssigned) +") \
                    OR (status = "+ str(constants.framesRunning) +"))") 
    logging.debug("I CANT BELIVE I AM HERE for host : "+ str(hostName) +" : Resetting frame status to "+ constants.framesStatus[statusReset])
    return(1)
  except:
    logging.error("resetAssignedFrame : "+ str(sys.exc_info()))
    return(0)
  
#def createRamDisk():
  #status = os.system("/sbin/mkfs.ext4 /dev/ram0")
  #if(not os.path.exists("/mnt/ramdisk")):
    #status +=  os.system("/bin/mkdir -m 0777 /mnt/ramdisk")
  #status += os.system("/bin/mount /dev/ram0 /mnt/ramdisk")
  #if(status == 0):
    #return(1)
  #return(0)
  

# taskFrame is a dict which contains all the info regarding the frame.
def assignFrameToHost(hostDetail, taskFrame):
  eThreads = 0
  if(taskFrame['threads'] == 0):
    if(hostDetail['eCpus'] == 0):
      eThreads = hostDetail['freeCpus']
    else:
      eThreads = hostDetail['freeCpus'] - (hostDetail['totalCpus'] - hostDetail['eCpus'])
  else:
    eThreads = taskFrame['threads']

  try:
    db_conn.execute("UPDATE hostResource \
                    SET freeCpus=freeCpus-"+ str(eThreads) +" \
                    WHERE hostName=\""+ hostDetail['hostName'] +"\"")
  except:
    logging.error("1 : "+ str(sys.exc_info()))
    return(0)
  try:
    db_conn.execute("UPDATE frames \
                    SET hostName=\""+ hostDetail['hostName'] +"\" , \
                    status="+ str(constants.framesAssigned) +", \
                    runCount=runCount+1 , \
                    fThreads="+ str(eThreads) +" \
                    WHERE frames.frameId="+ str(taskFrame["frameId"]) +" \
                    AND frames.id="+ str(taskFrame["id"]))
  except:
    logging.error("2 : "+ str(sys.exc_info()))
    try:
      db_conn.execute("UPDATE hostResource \
                      SET freeCpus=freeCpus+"+ str(eThreads) +" \
                      WHERE hostName=\""+ hostDetail['hostName'] +"\"")
    except:
      logging.error("2.5 : "+ str(sys.exc_info()))
    return(0)
  # The below code can be ignored?
  try:
    db_conn.execute("UPDATE tasksLog SET lastHost=\""+ hostDetail['hostName'] +"\" WHERE tasksLog.id="+ str(taskFrame['id']))
  except:
    logging.error("3 : "+ str(sys.exc_info()))
    
  return(1)

def getEffectiveDetails(hostName):
  try:
    rows4 = db_conn.execute("SELECT * FROM hostEffectiveResource WHERE hostName=\'"+ hostName +"\'", dictionary=True)
  except:
    return(0)
  return(rows4[0])
    
def arrangedActiveTasks():
  priorities = {}
  arrangedTasks = []
  activeTasks = getActiveTasks()
  afterTasks = {}
  #logging.debug("activeTasks :"+ str(activeTasks))
  if(activeTasks):
    for activeTask in activeTasks:
      try:
        priorities[activeTask["priority"]].append(activeTask)
      except:
        priorities[activeTask["priority"]] = []
        priorities[activeTask["priority"]].append(activeTask)
      #try:
        #afterTasks[activeTask["afterTasks"]].append(activeTask["id"])
      #except:
        #afterTasks[activeTask["afterTasks"]] = []
        #afterTasks[activeTask["afterTasks"]].append(activeTask["id"])
    pKeys = priorities.keys()
    pKeys.sort(reverse=True)
    #logging.debug("Sorted Keys :"+ str(pKeys))
    
    numPrios = len(pKeys)
    totalPrios = sum(pKeys)
    
    pcentPkeys = {}
    for pKey in pKeys:
      pcentPkeys[pKey] = (float(pKey) * 100) / float(totalPrios)
    #logging.debug("pcentPkeys :" + str(pcentPkeys))
      
    pcentPkeysRun = {}
    totalRunFrames = 0
    for pKey in pKeys:
      for activeTask in priorities[pKey]:
        runShit = getRunFrames(activeTask["id"])
        if(runShit):
          totalRunFrames = totalRunFrames + len(runShit)

    for pKey in pKeys:
      runFrames = 0
      for activeTask in priorities[pKey]:
        runShit = getRunFrames(activeTask["id"])
        if(runShit):
          runFrames = runFrames + len(runShit)
      try:
        pcentPkeysRun[pKey] = (100 * float(runFrames)) / float(totalRunFrames)
      except:
        pcentPkeysRun[pKey] = 0
    #logging.debug("pcentPkeysRun :"+ str(pcentPkeysRun)) 
    
    #The logic below SUCKS!!!! :`(  
    pKeysTmp = pKeys
    pKeysRevised = []
    while(len(pKeysTmp)):
      doneCrapping = 0
      for pKey in pKeysTmp:
        if(pcentPkeysRun[pKey] <= pcentPkeys[pKey]):
          pKeysRevised.append(pKey)
          pKeysTmp.remove(pKey)
          doneCrapping = 1
          break
      if(doneCrapping == 0):
        for pKey in pKeysTmp:
          pKeysRevised.append(pKey)
        break
        
    #logging.debug("RevisedPkeys : "+ str(pKeysRevised))    
    
    for pKey in pKeysRevised:
      pcent = {}
      for activeTask in priorities[pKey]:
        completedShit = 0
        completedShit = getRunFrames(activeTask["id"])
        allFrames = 0
        allFrames = getAllFrames(activeTask["id"])
        if(allFrames):
          numAllFrames = len(allFrames)
        else:
          return(0)
          
        if(completedShit):
          numCompletedShit = len(completedShit)
        else:
          numCompletedShit = 0
        percent = (100 * numCompletedShit) / numAllFrames
        try:
          pcent[percent].append(activeTask)
        except:
          pcent[percent] = []
          pcent[percent].append(activeTask)
      pcentKeys = pcent.keys()
      pcentKeys.sort()
      for pcentKey in pcentKeys:
        tasks = pcent[pcentKey]
        for task in tasks:
          arrangedTasks.append(task)
    #logging.debug("arrangeTasks :"+ str(arrangedTasks))
    
    
    ##get the tasks arranged according to afterTasks shits
    #if(afterTasks):
      #for afterT in afterTasks.keys():
        #afterTid = 
    
    return(arrangedTasks)
  else:
    return(0)
        
    
def getAllFrames(taskId):
  try:
    rows5 = db_conn.execute("SELECT frames.frameId, tasks.* FROM frames, tasks \
                    WHERE tasks.id=\'"+ str(taskId) +"\' \
                    AND tasks.id=frames.id \
                    ORDER BY frames.frameId", dictionary=True)
  except:
    logging.error(str(sys.exc_info()))
    return(0)
  return(rows5)
  
def getRunFrames(taskId):
  try:
    rows6 = db_conn.execute("SELECT frames.frameId, tasks.* FROM frames, tasks \
                    WHERE tasks.id="+ str(taskId) +" \
                    AND tasks.id=frames.id \
                    AND tasks.status="+ str(constants.taskActive) +" \
                    AND frames.status !="+ str(constants.framesUnassigned) +" \
                    ORDER BY frames.frameId", dictionary=True)
  except:
    logging.error(str(sys.exc_info()))
    return(0)
  return(rows6)
    
def resetFailedFrames(taskId):
  try:
    db_conn.execute("UPDATE frames SET status="+ str(constants.framesUnassigned) +" WHERE id="+ str(taskId) +" \
                    AND (status="+ str(constants.framesFailed) +" \
                    OR status="+ str(constants.framesKilled) +")")
    return(1)
  except:
    logging.error(str(sys.exc_info()))
    return(0)
  

  
def resetHungFrames(taskId, fId):
  try:
    db_conn.execute("UPDATE frames SET status="+ str(constants.framesUnassigned) +" WHERE (id="+ str(taskId) +") \
                    AND (frameId = "+ str(fId) +") \
                    AND (status="+ str(constants.framesHung) +")")
    return(1)
  except:
    logging.error(str(sys.exc_info()))
    return(0)
    
    
    
def getBestHost(activeTask):
  freeHosts = getFreeHosts()
  #logging.debug("free host : "+ str(freeHosts))
  #Try to giv to the last host that the task ran
  for freeHost in freeHosts:
    if(not activeTask['lastHost']):
      activeTask['lastHost'] = ""
    if(freeHost['hostName'].find(activeTask['lastHost']) >= 0):
      hostGroups = freeHost["groups"].split(",")
      taskGroups = activeTask["hostGroups"].split(",")
      hostOss = freeHost["os"].split(",")
      taskOss = activeTask["os"].split(",")
      inOSflag = 1
      for tOs in taskOss:
        if(tOs not in hostOss):
          inOSflag = 0
      
      inGroupFlag = 1
      for taskGroup in taskGroups:
        if(taskGroup not in hostGroups):
          inGroupFlag = 0
      
      if(inGroupFlag and inOSflag):
        if(freeHost['freeRam'] >= activeTask['minRam']):
          if(activeTask['threads'] == 0):
            if(freeHost['totalCpus'] - freeHost['freeCpus'] == 0):
              #logging.debug("free host : "+ str(freeHost))
              return(freeHost)
          else:
            if((freeHost['freeCpus'] - activeTask['threads']) >= (freeHost['totalCpus'] - freeHost['eCpus'])):
              #logging.debug("free host : "+ str(freeHost))
              return(freeHost)
    
  #If no last host then find a new one :)
  for freeHost in freeHosts:
    hostGroups = freeHost["groups"].split(",")
    taskGroups = activeTask["hostGroups"].split(",")
    hostOss = freeHost["os"].split(",")
    taskOss = activeTask["os"].split(",")
    inOSflag = 1
    for tOs in taskOss:
      if(tOs not in hostOss):
        inOSflag = 0
        
    inGroupFlag = 1
    for taskGroup in taskGroups:
      if(taskGroup not in hostGroups):
        inGroupFlag = 0
    if(inGroupFlag and inOSflag):
      if(freeHost['freeRam'] >= activeTask['minRam']):
        if(activeTask['threads'] == 0):
          if(freeHost['totalCpus'] - freeHost['freeCpus'] == 0):
            #logging.debug("free host : "+ str(freeHost))
            return(freeHost)
        else:
          if((freeHost['freeCpus'] - activeTask['threads']) >= (freeHost['totalCpus'] - freeHost['eCpus'])):
            #logging.debug("free host : "+ str(freeHost))
            return(freeHost)
  return(0)
        
    
    
    
  
def scheduler():
  setproctitle.setproctitle("scheduler")
  #db_conn = dbRbhus.dbRbhus()
  while(1):
    activeTasks = arrangedActiveTasks()
    #logging.debug("ACTIVE TASKS!!! :"+ str(activeTasks))
    if(activeTasks):
      #logic for afterTasks
      afterTasks = {}
    
      for activeTask in activeTasks:
        if(activeTask["afterTasks"]):
          ats = activeTask["afterTasks"].split(",")
          for at in ats:
            try:
              afterTasks[at.lstrip().rstrip()].append(activeTask)
            except:
              afterTasks[at.lstrip().rstrip()] = []
              afterTasks[at.lstrip().rstrip()].append(activeTask)
      if(afterTasks):
        for ats in afterTasks.keys():
          for ts in afterTasks[ats]:
            indx = -1
            try:
              indx = activeTasks.index(ts)
            except:
              continue
            if(indx != -1):
              for activeTask in activeTasks:
                if(activeTask["id"] == ats):
                  indxT = activeTasks.index(activeTask)
                  if(indx > indxT):
                    activeTasks.remove(activeTask)
                    activeTasks.insert(indx,activeTask)
                    activeTasks.remove(ts)
                    activeTasks.insert(indxT,ts)
                    
      freeHosts = getFreeHosts()
      #if(freeHosts):
        #logging.debug("freehosts : "+ str(freeHosts))
      if(freeHosts):
        for activeTask in activeTasks:
          #logging.debug("ACTIVE TASK ID : "+ str(activeTask['id']))
          assignedHost = getBestHost(activeTask)
          taskFramesAssigned = 0
          if(assignedHost):
            #logging.debug("bestHost "+ str(activeTask['id']) +":" + str(assignedHost))
            taskFrames = getUnassignedFrames(activeTask["id"])
            #logging.debug("taskFrames "+ str(activeTask['id']) +" :"+ str(taskFrames))
            if(taskFrames):
              taskFrame = taskFrames[0]
              while(1):
                if(assignFrameToHost(assignedHost, taskFrame)):
                  logging.debug("ASSIGNED to "+ assignedHost["hostName"] +" : "+ str(taskFrame["id"]) +" : "+ str(taskFrame["frameId"]))
                  taskFramesAssigned = 1
                  break
                time.sleep(0.1)
            else:
              while(1):
                if(resetFailedFrames(activeTask["id"])):
                  logging.debug("resetFailedFrames : "+ str(activeTask['id']))
                  break
                time.sleep(0.1)
          if(taskFramesAssigned == 1):
            break
    time.sleep(0.05)
  sys.exit(0)
 

def setCompletedTasks():
  setproctitle.setproctitle("setCompletedTasks")
  #db_conn = dbRbhus.dbRbhus()
  while(1):
    tasks = getActiveTasks()
    
    if(tasks):
      for task in tasks:
        if(task):
          status = checkTaskCompleted(task['id'])
          #logging.debug("active tasks wtf5 status: "+ str(status))
          #logging.debug("active tasks wtf5 : "+ str(task['id']) +"\n\n")
        
          if(status >= 0):
            while(1):
              if(setTaskStatus(task['id'],status)):
                break
              time.sleep(0.1)
    time.sleep(0.1)
 
 
def getHungFrames(taskId):
  try:
    rows7 = db_conn.execute("SELECT frames.frameId, tasks.* FROM frames, tasks \
                    WHERE tasks.id="+ str(taskId) +" \
                    AND frames.id= tasks.id \
                    AND frames.status="+ str(constants.framesHung) +" \
                    AND (tasks.rerunThresh>frames.runCount OR tasks.rerunThresh=0) \
                    ORDER BY frames.frameId", dictionary=True)
  except:
    logging.error(str(sys.exc_info()))
    return(0)
  return(rows7)
    


def resetHungFramesProc():
  setproctitle.setproctitle("resetHungFramesProc")
  #db_conn = dbRbhus.dbRbhus()
  while(1):
    tasks = getActiveTasks()
    if(tasks):
      for task in tasks:
        hFrames = getHungFrames(task['id'])
        if(hFrames):
          for hF in hFrames:
            resetHungFrames(hF['id'], hF['frameId'])
    time.sleep(1800)
    #keep this at 1800
    
    
    
def autoStopper():
  setproctitle.setproctitle("autoStopper")
  #db_conn = dbRbhus.dbRbhus()
  while(1):
    tasks = getActiveTasks()
    if(tasks):
      for task in tasks:
        if(task):
          allFrames = getAllFrames(task['id'])
          framesThresh = getFramesRerunThresh(task['id'])
          if(allFrames == 0):
            continue
          if(framesThresh == 0):
            continue
          totalFrames = len(allFrames)
          totalThresh = len(framesThresh)
          if((totalFrames - totalThresh) == 0):
            logging.debug("Auto stopping task : "+ str(task['id']))
            while(1):
              if(setTaskStatus(task['id'],constants.taskAutoStopped)):
                break
              time.sleep(0.05)
    time.sleep(0.5)
        
          
    
# Frames that have reached rerunThresh
def getFramesRerunThresh(taskId):
  try:
    rows8 = db_conn.execute("SELECT frames.* FROM frames, tasks \
                    WHERE tasks.id=\'"+ str(taskId) +"\' \
                    AND tasks.id=frames.id \
                    AND frames.runCount>=tasks.rerunThresh \
                    AND frames.status!="+ str(constants.framesDone) +" \
                    ORDER BY frames.frameId", dictionary=True)
  except:
    logging.error(str(sys.exc_info()))
    return(0)
  return(rows8)


#Return value is the status of the task that needs to be set
def checkTaskCompleted(taskId):
  try:
    compCount_ = db_conn.execute("SELECT COUNT(*) FROM frames WHERE frames.id="+ str(taskId) +" \
                    AND frames.status="+ str(constants.framesDone), dictionary=True)
    compCount = compCount_[0][compCount_[0].keys()[0]]
    totalCount_ = db_conn.execute("SELECT COUNT(*) FROM frames WHERE frames.id="+ str(taskId), dictionary=True)
    totalCount = totalCount_[0][totalCount_[0].keys()[0]]
    if(totalCount == compCount) :
      return(constants.taskDone)
    elif(((totalCount - compCount) == 0) and (totalCount != 0)):
      return(constants.taskWaiting)
    else:
      return(-2)
  except:
    logging.error(str(sys.exc_info()))
    return(-1)
    
    
def setTaskStatus(taskId,status):
  try:
    db_conn.execute("UPDATE tasks SET status="+ str(status) +" WHERE id="+ str(taskId))
    logging.debug("Updated task:"+ str(taskId) +" status to "+ str(status))
    return(1)
  except:
    logging.error(str(sys.exc_info()))
    return(0)

def reapAll():
  while(1):
    time.sleep(1)
    try:
      (pid,exitStatus) = posix.waitpid(-1,posix.WNOHANG)
    except OSError, e :
      logging.error(e)
      break
    if(pid == 0):
      continue
    if(pid != -1):
      logging.debug(str(pid) +" :: "+ str(exitStatus))
    else:
      break
  

def getMainPids():
  mainPidD = open(mainPidFile,"r")
  mainPids = []
  for x in mainPidD.readlines():
    mainPids.append(x.rstrip().lstrip())
    logging.debug("MAIN PIDS : "+ str(mainPids))
  if(mainPids):
    return(mainPids)
  else:
    return(0)  
  

if __name__ == "__main__":
  setproctitle.setproctitle("RBHUS:server")
  signal.signal(signal.SIGTERM,sigHandle)
  p = []
  pendTasks = multiprocessing.Queue()
  
  getWaitingTasks_proc = multiprocessing.Process(target=getWaitingTasks,args=(pendTasks,))
  p.append(getWaitingTasks_proc)
  getWaitingTasks_proc.start()
  
  
  time.sleep(2)
  
  
  initWaitingTasks_proc = multiprocessing.Process(target=initWaitingTasks,args=(pendTasks,))
  p.append(initWaitingTasks_proc)
  initWaitingTasks_proc.start()
  
  
  time.sleep(2)
  
  checkClientAlive_proc = multiprocessing.Process(target=checkClientAlive)
  p.append(checkClientAlive_proc)
  checkClientAlive_proc.start()
  
  time.sleep(2)
  
  setCompletedTasks_proc = multiprocessing.Process(target=setCompletedTasks)
  p.append(setCompletedTasks_proc)
  setCompletedTasks_proc.start()
  
  time.sleep(2)
  
  resetHungFramesProc_proc = multiprocessing.Process(target=resetHungFramesProc)
  p.append(resetHungFramesProc_proc)
  resetHungFramesProc_proc.start()
  
  time.sleep(2)
  
  autoStopper_proc = multiprocessing.Process(target=autoStopper)
  p.append(autoStopper_proc)
  autoStopper_proc.start()
  
  time.sleep(2)
  
  scheduler_proc = multiprocessing.Process(target=scheduler)
  p.append(scheduler_proc)
  scheduler_proc.start()
  
  pendTasks.close()
  
  pendTasks.join_thread()
  
  mainPidD = open(mainPidFile,"w",0)
  for i in range(0,len(p)):
    try:
      mainPidD.write(str(p[i].pid) +"\n")
    except:
      print("Couldnt write mainPidFile : "+ str(sys.exc_info()))
  mainPidD.close()
  
  while(1):
    time.sleep(1)
    if(not p):
      break
    for i in range(0,len(p)):
      if(p[i].is_alive()):
        time.sleep(0.5)
      else: 
        logging.debug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "MAIN Process dead : "+ str(p[i].pid))
        try:
          del(p[i])
        except:
          logging.debug(str(inspect.stack()[1][2]) +" : "+ str(inspect.stack()[1][3]) + " : "+ "MAIN Process dead . cannot delete index")
        break
  
  time.sleep(10)    
  #reapAll()